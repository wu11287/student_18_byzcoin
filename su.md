Algorand的选举过程
1. 根据每个节点money，分配对应权重
2. 前提是权重的 2/3 分配在诚实节点手中
3. 进行加密抽签，抽签满足要求的，作为这个阶段的区块提议者 --- 要求如何界定的
    - 注意每个节点都会对收到的交易进行排序
    - 一旦发现自己被选举成区块提议者，就会将交易打包成区块
    - 每个区块提议者都会打包区块的。但是区块提议者有优先级的概念，优先级高的区块会被其他人接受
    - 在强同步网络中，大家收到的最高优先级的区块是一样的
    - 每个区块提议者发出区块消息后，就自动失效，每个节点只能发一条消息
4. 再次加密抽签，选出BA共识节点
    - 对3的区块投票 -- 相当于prepare
5. 再次加密，选BA第二次共识节点
    - 对4同意的区块投票 --- commit
6. 区块写链，完成这一系列交易。

随机种子的计算


我的算法模拟
1. 2/3节点诚实。
2. 加密抽签，满足条件的被选择成整个系统的验证者
3. 对验证者进行分片 --- 参考omniledger的分片方式
4. 分片内部PBFT共识


加密抽签的输入
1. 公钥、随机种子、sk --- 经过vrf生成pi、hash
    - 这个hash固定长度，均匀分布
2. 同样设定被选举的权重数，满足的被选择成为验证者
3. 验证者分片



一、阈值如何界定
1. Algorand
- 设定一个 τ，决定该轮次的区块提议者的权重数
- 知道总体权重，决定抽签成功的概率p
- 得出某个节点i，拥有权重Wi，最后有j个权重被选中的

2. VRF
- VRF需要满足随机性
    - 1. 需要是随机分布，采用二项分布的是随机分布的
    - 2. 


## Omniledger相关，名词protobuf
1. skipchain Block
- 区块头存哈希值
- 区块body存储客户端交易：invoke、spawn、delete

2. 智能合约
- 解释客户端请求


3. collection
- 理解为一个merkle树的实现

4. proof
- 证明某个key在不在对应的skipchain中

5. darc
- 接入权限控制

6. 交易排序
- 会设定一个 MaxBlockSize。超过这个大小就给client返回fail. 表示当前不会在接受新的请求、
- 交易验证，不再这个过程中做。

# 模拟过程
1. 初始化模块：每个节点初始化id、权重、加密抽签，得到参与的idlist列表
2. 分片：根据idList列表进行全排列


# 想要效果
- 有多少分片就生成多少配置文件
- 配置文件名称是 shard0.txt
- 配置文件内容是片内的节点id。空格分割


过程
1. 生成公私钥广播
2. 加密抽签
3. 验证rnd，广播身份，形成idList
4. 根据随机排列进行分片处理


### 1. Elastico的pow分片模拟
1. 根据每个节点的IP、PK、rnd，计算一个满足结果的nonce值
2. hash会产生一个固定长度的字符串，取字符串的后s位作为分片的委员会个数



### 1. main.go的步骤
1. 生成公私钥 
2. 广播公私钥
3. 


# 语法篇
1. 调用shell脚本的方式
- `cmd := exec.Command("my_shell.sh")` 等同于  `sh my_shell.sh`


### docker-compose
- 定义和运行多容器docker程序


### 运行过程
1. 所有节点作为服务端，监听在50051端口
2. 假设开启两个client，这两个docker主机的ip是知道的
- client1和client2的互联
- 看这两个主机是否有预定结果 --- 打印pk和id
-