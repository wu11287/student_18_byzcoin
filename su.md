Algorand的选举过程
1. 根据每个节点money，分配对应权重
2. 前提是权重的 2/3 分配在诚实节点手中
3. 进行加密抽签，抽签满足要求的，作为这个阶段的区块提议者 --- 要求如何界定的
    - 注意每个节点都会对收到的交易进行排序
    - 一旦发现自己被选举成区块提议者，就会将交易打包成区块
    - 每个区块提议者都会打包区块的。但是区块提议者有优先级的概念，优先级高的区块会被其他人接受
    - 在强同步网络中，大家收到的最高优先级的区块是一样的
    - 每个区块提议者发出区块消息后，就自动失效，每个节点只能发一条消息
4. 再次加密抽签，选出BA共识节点
    - 对3的区块投票 -- 相当于prepare
5. 再次加密，选BA第二次共识节点
    - 对4同意的区块投票 --- commit
6. 区块写链，完成这一系列交易。

随机种子的计算


我的算法模拟
1. 2/3节点诚实。
2. 加密抽签，满足条件的被选择成整个系统的验证者
3. 对验证者进行分片 --- 参考omniledger的分片方式
4. 分片内部PBFT共识


加密抽签的输入
1. 公钥、随机种子、sk --- 经过vrf生成pi、hash
    - 这个hash固定长度，均匀分布
2. 同样设定被选举的权重数，满足的被选择成为验证者
3. 验证者分片



一、阈值如何界定
1. Algorand
- 设定一个 τ，决定该轮次的区块提议者的权重数
- 知道总体权重，决定抽签成功的概率p
- 得出某个节点i，拥有权重Wi，最后有j个权重被选中的

2. VRF
- VRF需要满足随机性
    - 1. 需要是随机分布，采用二项分布的是随机分布的
    - 2. 


## Omniledger相关，名词protobuf
1. skipchain Block
- 区块头存哈希值
- 区块body存储客户端交易：invoke、spawn、delete

2. 智能合约
- 解释客户端请求


3. collection
- 理解为一个merkle树的实现

4. proof
- 证明某个key在不在对应的skipchain中

5. darc
- 接入权限控制

6. 交易排序
- 会设定一个 MaxBlockSize。超过这个大小就给client返回fail. 表示当前不会在接受新的请求、
- 交易验证，不再这个过程中做。